Kernel 4 Design
	(wenn das so weiter geht brauch ich ne 64bit Zahl ... xD)
================================================================================

// Mit Monospace Schriftart und einer Tabulatorbreite von 4 anzusehen

Grundidee:
________________________________________________________________________________
Alles Plattformunabhängige und Architekturspezifische kommt in den Kernel, der
Rest wird in Module ausgelagert. Sogar die CPU ist als Datei verfügbar, was
schnelle Portierung auf andere Prozessorarchitekturen ermöglicht. 


Beispielaufteilung:
________________________________________________________________________________
Im Kernel enthalten:
	- physische Speicherverwaltung
	- Prozessverwaltung
	- VFS
	- ELF Loader
	- Treiberschnittstelle (dafür das VFS, Geräte sind Dateien im Ordner "/dev")
	- Architekturspezifisches Zeug

Extra Module:
	- ibmpc.mod - Treiber für Textmodus, Tastatur, PC-Speaker, ...
	und alles was es sonst an Treibern gibt

	
Beschreibung:
________________________________________________________________________________
Alle Module die automatisch starten müssen/gestartet werden sollen liegen in der
initrd. Die initrd ist ein LF FFS Archiv (tar-ähnlicher Eigenbau; schon
implementiert) in dem die Module und eine Indexdatei liegen. In der Indexdatei
stehen untereinander die Namen der Module. Damit wird die Reihenfolge bestimmt.
Das Plattformmodul sollte aus naheliegenden Gründen an erster Stelle liegen.
Wenn ein Modul von einem anderen abhängt muss es nach dem entsprechenden anderen
Modul geladen werden. Ringabhängigkeiten sind damit verboten.

Jedes Modul hat eine Global eindeutige ID (GUID oder UUID, ist ja das gleiche).
Ein Modul kann einen eigenen Syscall beantragen. Programme die mit einem
bestimmten Modul kommunizieren müssen können das über diesen Syscall machen. Die
Nummer des Syscalls kann per Syscall und der GUID des Moduls vom Kernel erfragt
werden.


Aufbau eines Moduls
________________________________________________________________________________
Jedes Modul hat eine Funktion zum initialisieren (main()) in der die Geräte und
Events angemeldet werden. Außerdem kann dort Modulspezifischer Code ausgeführt
werden. Etwa initialisieren der CPU.
Außerdem sind in einem Modul verschiedene Callback-Funktionen enthalten die auf
die registrierten Geräte angemeldet wurden. Damit kann der Kernel mit dem Modul
kommunizieren (Auf Gerät schreiben -> per Callback an Treiber -> Hardware).

Als Binärformat für Module wird das (überall gerne verwendete) ELF-Format
verwendet. 
	
	
Grafisch für die, die nicht gerne lesen ;)
________________________________________________________________________________

 _______________________		 _____________________________________________
| LF OS Kernel 4        |		| ibmpc.mod - Treiber für IBM kompatible PC's |
|_______________________|		|_____________________________________________|
| Prozessverwaltung     |		|						° ...				  |
| Speicherverwaltung    | <---< |						° ...				  |
| ELF Loader            |  VFS  |						° ...				  |
| VFS                   | >---> |_____________________________________________|
| Treiber API           |
| initrd Loader (LF FFS)|
| API für Events (int)  |
|_______________________|
				v	^			 ________________________
				|  	|	VFS		| Anderes Modul          |
				|	'---------<	|________________________|
				'------------->	| Spezielle Gerätetreiber|
								|________________________|
								
int = Interrupt/Exceptions/IRQs
